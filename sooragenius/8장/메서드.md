# 매개변수가 유효한지 검사하라
제약은 반드시 문서화해야 하며 ***메서드 몸체가 시작되기 전에*** 검사해야 한다.  
매개변수 검사가 잘 수행되지 안흥면 몇가지 문제가 발생된다.  

메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.  
더 나쁜 상황은 프로그램이 정상적으로 작동은 하지만 결과가 이상하게 나올 수 있다는 것이다.  
더 나쁜 상황은 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어 놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 떄다.  
public, protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.  
매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.  

public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증 할 수 있다. (-ea 옵션을 주어야함.)

메서드 몸체 실행 전에 매개변수 유효성을 검사해야 한다는 규칙에도 예외는 존재한다.  
유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산과정에서 암묵적으로 검사가 수행될 때 다.
# 적시에 방어적 복사본을 만들라
클라이언트가 불변식을 꺠뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.  
파라미터로 넘어온 데이터는 heap에 ref하기 때문에 불변식을 깨트릴 수 있다.  
가변 매개변수를 방어적으로 복사하여야만 한다.  
그러한 다음 원본이 아닌 복사본을 사용하도록 해야 한다.  
멀티쓰레드 환경도 고려를 해야한다.  
복사본을 만들고 본사본으로 validation을 해야하는 경우가 생길것이다. 만약 validation 후 복사본을 만들경우 값이 바뀔 수도 있다.

클래스가 불변이든 가변이든 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고해야 한다.  
안심할 수 없다면 복사본을 만들어야한다.  
길이가 1 이상인 배열은 무조건 가변이다.  

# 메서드 시그니처를 신중히 설계하라
1. 메서드 이름을 신중히 짓자.  
항상 표준 명명 규칙을 따라야 한다.  
이해하기 편하고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는 게 최우선이다.  
긴 이름은 피하고 개발자 커뮤니티에서 쓰이는 이름을 써야한다.  
2. 편의 메서드를 너무 많이 만들지 말자.
메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 힘들다.  
아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두기 바란다.  
확신이 서지 않으면 만들지 말자.  
3. 매개변수 목록은 짧게 유지하자.  
4개가 넘어가면 매개변수를 전부 기억하기 쉽지 않다.  
같은 타입의 매개변수 여러 개가 연달아 나오는 경우는 해롭다.
해결하기 위한 3가지 방안  
    1. 여러 메서드로 쪼갠다.  
    쪼개진 메서드 각각은 원래 매개변수 목록의 부분집합을 받는다.  
    잘못하면 메서드가 많아질 수는 있지만, 직교성을 높여 오히려 메서드 수를 줄여주는 효과가 있다.
    (직교성 : 공통점이 없는 기능들이 잘 분리되어 있다.)
    2. 여러 개를 묶어주는 도우미 클래스를 만들어라.  
    카드게임 파라미터를 예로 할경우 숫자와 무늬를 뜻하는 두개의 매개변수가 아닌 클래스 하나로 전달을 한다.
    3. 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다고 보면 된다.
    객체 생성에 사용한 빌더패턴을 메서드 호출에 응용한다고 생각하자.  
매개 변수의 타입으로는 클래스보다는 인터페이스가 더 낫다. HashMap 대신 Map을 사용하자.
boolean보다는 원소 2개짜리 열거 타입이 낫다. 열거타입은 코드를 읽고 쓰기가 더 쉬워진다.  

# 다중정의는 신중히 사용하라
```java
package effectivejava.chapter8.item52;
import java.util.*;
import java.math.*;

// 코드 52-1 컬렉션 분류기 - 오류! 이 프로그램은 무엇을 출력할까? (312쪽)
public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "집합";
    }

    public static String classify(List<?> lst) {
        return "리스트";
    }

    public static String classify(Collection<?> c) {
        return "그 외";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(),
                new ArrayList<BigInteger>(),
                new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```
호출하면은 결과는 집합 -> 리스트 -> 그 외로 표출될것 같지만 결과는 그 외로만 표출이된다.
왜냐하면 ***오버로딩된것은 컴파일 타임***때 어떤 메서드가 호출될지 결정하기 떄문이다.  
런타임때는 타입이 매번 달라지지만 오버로딩 호출은 컴파일타임때 정의되기 때문이다.   
이처럼 직관과 어긋나는 이유는 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택되기 때문이다  
varargs를 사용할 경우에는 다중정의를 아예 하지 말아야한다  
다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 좋은 방법이다.  

다중정의할 때 매개변수 중 하나 이상이 근본적응로 다르면 문제는 없다.  
근본적으로 다른것은 매개변수가 서로 캐스팅 될 수 없다는 뜻이다.    
List의 remove는 2가지로 정의가 되어있다  
remove(Object)와 remove(int)  
만약에 remove(1)로 하면 무엇이 호출이 될까 remove(int)가 호출이된다.  
만약 remove(Object)를 호출하고싶으면 (Integer)로 변경해서 하면된다.  
