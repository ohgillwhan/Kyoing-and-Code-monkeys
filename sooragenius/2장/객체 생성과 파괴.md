1. 객체를 만들어야 할 때와 만들지 말아야 할 때 구분법
2. 올바른 객체 생성 방법과 불필요한 생성을 피하는 법
3. 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 법

1. 생성자 대신 정적 팩터리 메서드를 고려해라
    - 기본적으로 전통적인 방법은 public 생성자다.
    public 생성자와 별도로 정적 팩터리 메서드로 제공이 가능하다.
    
    - 정적 팩터리 메소드의 장점
        1. 이름을 가질 수 있다.
            - public 생성자의 경우 이름을 명시할 수 없지만 정적으로 제공되는 함수를 통해서는 이름 제공이 가능하다.
            - 파라미터로 생성자를 오버로딩이 가능하지만 의미를 부여를 할 수는 없다.
            - BigInteger(int, int, Random) 보다는 BigInteger.probablePrime이 더 의미가 부여가 되어있다.
        2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
            - 미리 만들어놓아 제공해주면 된다.
                - 만약에 캐릭터 정보가 필요로 하다고 생각을 해보자.
                - 전사, 마법사, 도적 등의 직업이 있고 이 직업에 대해 기본적인 MetaData를 제공해야 한다.
                    그러면 계속 new를해서 이 정보를 뿌려줄것인가?
                    한번 만들어놓고 그 정보에대해서 계속 표출해주면은 성능적으로 더 좋아질것이다.
            - 메모리 소비를 아낄 수 있다.
            - 싱글턴을 구현이 가능하다.
                싱글턴을 이용하여 a.equals(b)가 아닌 a == b도 가능하다
            - 인스턴스화 불가가 가능하다.
                - Math같이 유틸성의 객체는 Instance화가 필요없다.
                - 그러므로 private로 생성자를 만들면은 인스0턴스화 불가능 하도록 가능하다.
            - 객체에 대해서 컨트롤이 가능하게 된다.
                몇개의 인스턴스가 생성이 되었는지, 객체에 대해서 notify도 가능할것 같다.
                    생성자로도 해당 기능은 한 기능이다.
        3. 반환타입의 하위 타입 객체를 반환 할 수 있는 능력이 있다.
            - 캐릭터라는 Interface를 만들고 전사, 도적, 궁수등을 상속받아 객체 생성자가 가능할것이다.
        4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
            - 3번과 동일하게 파라미터에 따라서 하위객체가 변경이 될 수 가 있다.
        5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
            - 서비스 제공자 프레임워크를 만드는 근간이 됨(JDBC)
                - 클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시 할 수 있다.
                    1. 서비스 인터페이스
                        - JDBC의 Connection
                    2. 제공자 등록 API
                        - JDBC의 DriverManager.registerDriver
                    3. 서비스 접근 API
                        - JDBC의 DriverManager.getConnection
    - 정적 팩터리 메소드의 단점
        1. 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
            - 생성자 처럼 API설명에 명확히 드러나지 않으니 찾기 힘들다.
2. 생성자에 매개변수가 많다면 빌더를 고려하라
    - 생성자의 매개변수가 매우 가변적일시 해결이 가능한 방법
        1. 필요한 컬럼마다의 생성자를 만든다.
            - 만약에 생성자 컬럼이 매우 가변적일 경우엔 생성자가 여러개가 나올것이다.
            - 필요한 생성자마다 생성하는걸 점층적 생성자 패턴이라고 한다.
        2. 자바빈즈의 setter를 사용한다
            - 1번보다는 좋지만 메서드를 여러개 호출되야 하며 객체 완성전에는 일관성이 무너진 상태이다.
            - 만약에 set중 다른 쓰레드가 낚아채버리면 문제가 될것이다.
        3. builder 패턴을 사용한다
            - 빌더패턴을 이용하면은 연쇄호출이 가능하다.
            - 코드를 쓰기 쉽고 읽기 매우 편하다.
            - 하위 클래스도 builder 패턴의 확장이 매우 편하다.
3. private 생성자나 열거 타입으로 싱글턴임을 보증하라
    - 싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스
    - 싱글턴의 전형적인 예로는 함수와 같은 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트
    - 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워진다.
        - mock 구현으로 대체할 수 없기 때문이다
    - 싱글턴을 만드는 방법
        1. 생성자를 private 로 만들고 인스턴스에 접근할 수 있는 수단으로는 public static final 로 변수를 선언한다
            - 객체가 public static final이므로 싱글턴임이 바로 확인이 된다.
            - 그리고 매우 간결한 싱글톤이
        2. 생성자를 private 로 만들고 인스턴스에 접근할 수 있는 수단으로는 public static 의 함수를 선언해준다.
            - 언제든 싱글톤을 해제할 수 있다.
                - new를 해서 리턴해주면 싱글턴이 깨진다
            - 제네릭 싱글턴 팩터리로 만들 수 있다
            - Supplier로 사용이 가능하다
                - Object::getSingletoneInstance
        3. 원소가 하나인 열거 타입을 선언한다.
            - 손쉬운 직렬화가 가능하다
            - 리플렉션 공격에서 방어가 된다.
4. 인스턴스화를 막으려거든 private 생성자를 사용하라
    - 객체지향적으로 사고하지 않는 이들이 종종 남용하는 방식이기에 곱게 보이지는 않지만, 쓰임세는 있다.
    - java.lang.Math, java.util.Arrays처럼 기본 타입 값이나 배열 관련 메서드들을 모을수 있다.
    - 정적 팩터리 메소드등을 모을 수 있다.
    - final 클래스와 관련한 메서드들을 모아놓을 때도 사용한다.
        (https://gmlwjd9405.github.io/2018/08/06/java-final.html)
    - 추상클래스로는 인스턴스화를 막을 수 없다
        - 상속받아서 구현하면은 치팅이 가능하다.
    - private 생성자를 만들면 상속을 못하게 가능하다
        ????
5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
    - 싱글톤이 아닌 확장이 되는 상황에서는 싱글톤으로 명시하지 말라
    - 확장이 필요할때는 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주라
6. 불필요한 객체 생성을 피하라
    - 같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용 하는편이 나을 때가 많다.
        - new String("bikini") 대신 "bikini"를 사용해라
            - new를 할때마다 새로운 인스턴스를 생성을 한다.
            - 하지만 "bikini"라고 정의를 하면은 같은 가상 머신 안에서 같은 문자가 있을경우 재사용을 보장한다.
        - new Boolean 대신 Boolean.valueOf등을 사용하라
            - 내부적으로 Boolean.valueOf는 싱글턴을 보장한다.
    - 생성 비용이 아주 비싼 객체는 캐싱하여 재사용해라
    - 오토박싱을 조심해라
        - 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
            - 의미상으로는 별다를 것 없지만 성능에서는 엄청난 차이가 난다
                - Integer integer = 3; // 오토박싱
                - int i = integer; // 오토언박싱
        - 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 조심하라.
    - 아주 무거운 객체외에는 풀을 만들어서 사용하지 마라
        - DB 커넥션 등의 비싼 객체외에는 풀을 만들경우 오히려 리소스 낭비와 속도가 느릴 수 있다.
7. 다 쓴 객체 참조를 해제하라
    - 메모리를 직접 관리하는 언어에서 자바로 넘어올땐 엄청난 편안함을 느낀다.
    - 그래서 자칫 메모리 관리에 신경을 쓰지 않아도 된다고 생각하지만 조심해야한다.
    - 소스코드상에서 재참조의 일은 없는 객체는 자동으로 소멸될거라고 생각하지만 GC입장에서는 재참조의 일이 없는 객체도 객체이다.
        - 다 쓴 참조는 null로 해제를 해준다.
            - 다 쓴 객체를 null로 설정할경우 GC대상이 되며 만약 해당 객체에 접근시 NullPointerException이 발생되어 좋은 효과가 나타난다
            - 하지만 이 방법은 100%좋은 방법이 아니다.
            - 가장 좋은 방법은 유효범위 밖으로 밀어내는 것이다.
    - 캐시도 메모리 누수를 일으키는 주범이다.
        - WeakHashMap를 사용하여 Key가 살아있을때만 Value가 존재하도록 구현이 가능하다.
        - 캐시를 만들때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 떄문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식으로 흔히 사용한다.
            - 백그라운드 쓰레드를 이용하여 가치를 떨어트린다.
            - 새 엔트리를 추가하는 등의 특별한 로직이 있을때 가치를 떨어트린다.
    - 콜백 혹은 리스너도 메모리 누수의 주범이다.
        - 콜백과 리스너를 등록해놓고 해지하지 않는다면 그것도 메모리의 낭비이다
            - 해당 객체를 WeakHashMap에 키로 등록하고 콜백을 Value에 저장하면 해결 될것 같다.
8. finalizer와 cleaner 사용을 피하라
    - 자바에서는 2가지의 객체 소멸자를 제공한다.
        - finalizer는 예측할 수 없고 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
            - 오동작, 낮은 성능, 이식성 문제가 되어 자바9부터 사용자제가 걸렸다.
        - cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
        - finalizer와 cleaner는 위험하다
            - GC가 언제 동작할지 모르므로 언제 회수될지 모른다.
            - 속도적으로 매우 느리다
    - cleaner와 finalizer 대신 try-with-resources를 사용하
    - 그러면 어떨때 finalizer와 cleaner를 사용하는가?
        - 객체가 close되지 않았을 때를 대비하여 사용한다 ( https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/io/FileInputStream.java )
        - 네이티브 피어와 연결되었을때 사용한다
            - 네이티브 피어란 일반 자바객체가 네이티브메서드를 통해 기능을 위임한 네이티브 객체를 말한다.
            - 네이티브 피어는 GC가 모르기 때문에 cleaner와 finalzier 를 사용하여 회수한다.
            - 하지만 성능저하가 있다. 
9. try-finally보다는 try-with-resources를 사용하라.
    - 자바 라이브러리는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. (InputStream, OutputStream. java.sql.connection)
    - 자원을 닫지 않으면 예쌍치 못한 성능저하가 발생한다.
        - 해당 이슈를 방지하기 위해 finalizer를 사용하기는 한다..
    - 전통적으로 try-finally를 사용했다.
        - 이 방식으로 하면은 try { try { try { } } } 형태가 나올때가 많다.
        - 그리고 close를 생각을 못할 경우가 많아진다.
    - AutoCloseable을 implements를 받아서 구현이 가능하다.