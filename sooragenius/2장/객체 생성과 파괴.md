1. 객체를 만들어야 할 때와 만들지 말아야 할 때 구분법
2. 올바른 객체 생성 방법과 불필요한 생성을 피하는 법
3. 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 법

1. 생성자 대신 정적 팩터리 메서드를 고려해라
    - 기본적으로 전통적인 방법은 public 생성자다.
    public 생성자와 별도로 정적 팩터리 메서드로 제공이 가능하다.
    
    - 정적 팩터리 메소드의 장점
        1. 이름을 가질 수 있다.
            - public 생성자의 경우 이름을 명시할 수 없지만 정적으로 제공되는 함수를 통해서는 이름 제공이 가능하다.
            - 파라미터로 생성자를 오버로딩이 가능하지만 의미를 부여를 할 수는 없다.
            - BigInteger(int, int, Random) 보다는 BigInteger.probablePrime이 더 의미가 부여가 되어있다.
        2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
            - 미리 만들어놓아 제공해주면 된다.
                - 만약에 캐릭터 정보가 필요로 하다고 생각을 해보자.
                - 전사, 마법사, 도적 등의 직업이 있고 이 직업에 대해 기본적인 MetaData를 제공해야 한다.
                    그러면 계속 new를해서 이 정보를 뿌려줄것인가?
                    한번 만들어놓고 그 정보에대해서 계속 표출해주면은 성능적으로 더 좋아질것이다.
            - 메모리 소비를 아낄 수 있다.
            - 싱글턴을 구현이 가능하다.
                싱글턴을 이용하여 a.equals(b)가 아닌 a == b도 가능하다
            - 인스턴스화 불가가 가능하다.
            - 객체에 대해서 컨트롤이 가능하게 된다.
                몇개의 인스턴스가 생성이 되었는지, 객체에 대해서 notify도 가능할것 같다.
                    생성자로도 해당 기능은 한 기능이다.
        3. 반환타입의 하위 타입 객체를 반환 할 수 있는 능력이 있다.
            - 캐릭터라는 Interface를 만들고 전사, 도적, 궁수등을 상속받아 객체 생성자가 가능할것이다.
        4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
            - 3번과 동일하게 파라미터에 따라서 하위객체가 변경이 될 수 가 있다.
        5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
            - 서비스 제공자 프레임워크를 만드는 근간이 됨(JDBC)
                - 클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시 할 수 있다.
                    1. 서비스 인터페이스
                        - JDBC의 Connection
                    2. 제공자 등록 API
                        - JDBC의 DriverManager.registerDriver
                    3. 서비스 접근 API
                        - JDBC의 DriverManager.getConnection
    - 정적 팩터리 메소드의 단점
        1. 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
            - 생성자 처럼 API설명에 명확히 드러나지 않으니 찾기 힘들다.
2. 생성자에 매개변수가 많다면 빌더를 고려하라
    - 생성자의 매개변수가 매우 가변적일시 해결이 가능한 방법
        1. 필요한 컬럼마다의 생성자를 만든다.
            - 만약에 생성자 컬럼이 매우 가변적일 경우엔 생성자가 여러개가 나올것이다.
            - 필요한 생성자마다 생성하는걸 점층적 생성자 패턴이라고 한다.
        2. 자바빈즈의 setter를 사용한다
            - 1번보다는 좋지만 메서드를 여러개 호출되야 하며 객체 완성전에는 일관성이 무너진 상태이다.
            - 만약에 set중 다른 쓰레드가 낚아채버리면 문제가 될것이다.
        3. builder 패턴을 사용한다
            - 빌더패턴을 이용하면은 연쇄호출이 가능하다.
            - 코드를 쓰기 쉽고 읽기 매우 편하다.
            - 하위 클래스도 builder 패턴의 확장이 매우 편하다.
3. private 생성자나 열거 타입으로 싱글턴임을 보증하라
    - 싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스
    - 싱글턴의 전형적인 예로는 함수와 같은 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트
    - 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워진다.
        - mock 구현으로 대체할 수 없기 때문이다
    - 싱글턴을 만드는 방법
        1. 생성자를 private 로 만들고 인스턴스에 접근할 수 있는 수단으로는 public static final 로 변수를 선언한다
            - 객체가 public static final이므로 싱글턴임이 바로 확인이 된다.
            - 그리고 매우 간결한 싱글톤이
        2. 생성자를 private 로 만들고 인스턴스에 접근할 수 있는 수단으로는 public static 의 함수를 선언해준다.
            - 언제든 싱글톤을 해제할 수 있다.
                - new를 해서 리턴해주면 싱글턴이 깨진다
            - 제네릭 싱글턴 팩터리로 만들 수 있다
            - Supplier로 사용이 가능하다
                - Object::getSingletoneInstance
        3. 원소가 하나인 열거 타입을 선언한다.
            - 손쉬운 직렬화가 가능하다
            - 리플렉션 공격에서 방어가 된다.
4. 인스턴스화를 막으려거든 private 생성자를 사용하라
    - 객체지향적으로 사고하지 않는 이들이 종종 남용하는 방식이기에 곱게 보이지는 않지만, 쓰임세는 있다.
    - java.lang.Math, java.util.Arrays처럼 기본 타입 값이나 배열 관련 메서드들을 모을수 있다.
    - 정적 팩터리 메소드등을 모을 수 있다.
    - final 클래스와 관련한 메서드들을 모아놓을 때도 사용한다.
        (https://gmlwjd9405.github.io/2018/08/06/java-final.html)
    - 추상클래스로는 인스턴스화를 막을 수 없다
        - 상속받아서 구현하면은 치팅이 가능하다.
    - private 생성자를 만들면 상속을 못하게 가능하다
        ????
5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
    - 싱글톤이 아닌 확장이 되는 상황에서는 싱글톤으로 명시하지 말라
    - 확장이 필요할때는 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주라
6. 불필요한 객체 생성을 피하라.
    - 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.
    - 재사용은 빠르고 세련되다.
        - new String("bikini"); 보다는 "bikini"를 사용하라
        - 후자로 생성하면 재사용이 내부적으로 보장이 된다
        
        - 정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 피하
        - new Boolean(String) 보다는 Boolean.valueOf()를 사용하라
            - oolean은 내부적으로 싱글톤을 사용중이다
            
    - 비싼 리소스를 사용하는 객체는 캐싱처리를 해라.
    - 오토 박싱을 피해라
        - Long 에다가 숫자를 더하면은 속도가 느려진다
        - long 에다가 숫자를 더하면은 속도가 빨라진다.
    - 객체풀을 의미없게 만들지 마라
        - 아무리 메모리가 좋아졌다고 하더라도 리소스 낭비가 생긴다.
        - 가벼운 객체를 다룰때는 new가 직접 만든 객체풀보다 훨씬 빠르다