# 1.equals는 일반 규약을 지켜 재정의하라.
equals는 재정의하기 쉬워 보이지만 곳곳에 함정이 있다.  
이 함정을 피하는 방법은 재정의 하지 않는것이다.
아래중 한개라도 해당이되면 하지 않는것이 좋다.
1. 각인스턴스가 본질적으로 고유하다.
    - 값을 표현하는게 아닌 동작하는 개체를 표현하는 클래스가 여기에 해당한다.
    - Thread가 제일 좋은예이다.
2. 논리적 동치성을 검사할 일이 없다.
    - Pattern을 정의해서 논리적(logical equailty)을 검사가 가능하다.
    - 설계자는 클라이언트가 이 방식을 원하지 않거나 애초에 필요하지 않다고 판단할 경우 기본 Object equals로 가능하다.
3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
    - Set이나 List나 Map은 AbstractMap을 상속받아 구현한다.
4. 클래스가 private이거나 private-package일 경우 equals 메서드를 호출할 일이 없다.
    - equals안에 Exception을 발생시켜라

## 그렇다면 언제 재정의 하는가?
객체 식별성( 두 객체가 물리적으로 같은가 )이 아니라 논리적 동치성을 확인해야 하는데.  
상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의가 안되어있을때다.
주로 값 클래스가 여기에 해당된다.
## 값 클래스란 ?
Integer,String 처럼 값을 표현하는 클래스이다.
두 값 객체를 equals로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶은 것이다.

Equals를 논리적 동치성을 확인하도록 재정의 할경우 그인스턴스는 값을 비교하길 원하는 프로그래머의 기대의 부흥을 넘어서
Map의 키와 Set의 원소로 사용이 가능하다.

값 클래스라 해도 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의 하지 않아도 된다. (Enum)  
이러한 경우는 어차피 논리적으로 같은 인스턴스가 2개가 만들어지지 않으니 문제가없다.
## euquals 메서드를 재정의시 반드시 지켜야 할 규약
`
equals 메서드는 동치관계를 구현하며, 다음을 만족한다.
1. 반사성 : null 이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true이다.
    - 객체는 자기 자신과 같아야 한다.
2. 대칭성 : null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)가 true면 y.equals(x)는 true이다.
    - 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다는 조건이다.
3. 추이성 : null이 아닌 모든 참조 값 x,y,z,에 대해, x.equals(y)가 true이면 x.equals(z)도 true이면 x.equals(z)도 true이다.
    - 첫 객체와 두 객체가 같고 두 객체가 세번째 객체와 같으면 첫 객체는 세번째 객체와 같아야 한다.
4. 일관성 : null이 아닌 모든 참조 값 x,y에 대해 x.equakls(y)를 반복해서 호출하면 항상 true또는 false를 반환한다.
    - 두 객체가 다르게 수정되지 않는 한 앞으로도 영원히 같아야 한다.
5. null-아님 : null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false이다.

사실 위에 내용은 같은 클래스가 아닌 다른 클래스였을때도 동작했으면 한다.  
리스코프 치환원칙을 지키면서 구현해야한다.
`
## 동치관계란?
집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산.
equals 메소드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다.


# 2. equals를 재정의 하려거든 hashcode도 재정의 하라
** equals를 재정의한 클래스 모두에서 hashcode도 재정의 해야 한다. **
만약 재정의 하지 않을경우 hashset이나 hashmap에서 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.
## Object 명세
1. equals 비교에 사용되는 정보가 변경하지 않았다면은 어플리케이션이 재실행 까지 hashcode는 변하지 않아야 한다.
2. equals가 두 객체를 같다고 판단했을경우 hashCode도 같아야한다.
3. equals가 두 객체를 다르다고 판단했더라고 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

**논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.**  
`
Map User = new HashMap();  
User.put(new TelNo(123,456,7890), "제니");
User.get(new TelNo(123,456,7890)) -> null return
`
위에 예제는 다른 hashcode를 갖고있기 때문에 return null이 떨어진다.
두번째에서 논리적 동치인 객체를 사용하여 꺼내려고 했으니 HashCode가 같지 않기에 null이 나온것이다.
## 최악의 ( 하지만 적법한 ) hashCode 구현 - 절대 사용 X
`
public int hashCode() { return 42; }
`  
위에 코드로 사용할 경우 해쉬맵의 O(1)은 O(N)으로 변하게 된다.  
인스턴스는 32비트로 적당히 분배가 잘 되어야한다.
## hashcode 만들시 참고할점
1. 만들고 나서 Test코드로 equals와 hashcode가 같은지 테스트 해야한다. (물론 자동으로 만들어진것이면 뛰어넘어도 된다)
2. 파생 필드는 해시코드 계산에서 제외해도 된다.  
3. equals에 사용하지 않은 객체는 무조건 제외해야한다.  
4. Object.hash나 Guava의 Hash를 사용해도된다. ( 하지만 Object.Hash는 느리다 )  
5. 객체가 불변이며 해시코드를 만드는데 시간이 많이 걸린다면은 캐싱하여 사용하자.  
6. 성능을 높인다고 중요한 필드를 빼먹거나 짤라서 사용하지 말아야 한다 ( 자바2의 String이 그러했음. )


